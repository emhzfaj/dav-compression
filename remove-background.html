<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Background Remover</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .file-upload-label {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        #canvas-wrapper {
            position: relative;
            width: 100%; /* Make wrapper responsive */
        }
        #imageCanvas, #drawCanvas {
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 0.5rem; /* rounded-lg */
            max-width: 100%;
            height: auto;
        }
        #imageCanvas {
            background-image:
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            z-index: 1;
        }
        #drawCanvas {
            z-index: 2;
            pointer-events: none; /* Pass clicks through to the image canvas */
        }
        .mode-btn.active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
        }
        .action-btn:disabled {
            background-color: #4a5568; /* gray-700 */
            cursor: not-allowed;
            opacity: 0.5;
        }
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 8px; cursor: pointer; background: #4a5568; border-radius: 5px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #6366f1; cursor: pointer; margin-top: -6px; }
        input[type=range]::-moz-range-track { width: 100%; height: 8px; cursor: pointer; background: #4a5568; border-radius: 5px; }
        input[type=range]::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: #6366f1; cursor: pointer; }
        input[type="color"] { -webkit-appearance: none; border: none; width: 48px; height: 40px; padding: 0; border-radius: 8px; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid #4a5568; border-radius: 8px; }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto p-6 md:p-8 bg-gray-800 rounded-2xl shadow-2xl text-center">
        <h1 class="text-3xl md:text-4xl font-bold mb-3">Image Editor</h1>
        <p class="text-gray-400 mb-6">Upload an image, then choose a mode to edit.</p>

        <!-- File Upload Area -->
        <div id="upload-container" class="mb-6">
            <label for="imageLoader" class="file-upload-label bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                Upload Image
            </label>
            <input type="file" id="imageLoader" name="imageLoader" class="hidden" accept="image/*"/>
        </div>

        <!-- Canvas Wrapper -->
        <div id="canvas-wrapper" class="mx-auto mb-6 hidden">
             <canvas id="imageCanvas" class="shadow-md"></canvas>
             <canvas id="drawCanvas"></canvas>
        </div>
        
        <!-- Controls Area -->
        <div id="controls-container" class="hidden my-6 px-4 space-y-6">
            <!-- Mode Toggle -->
            <div class="flex justify-center bg-gray-700 rounded-lg p-1">
                <button id="modeColor" class="mode-btn active w-1/3 py-2 px-4 rounded-md text-sm font-medium transition">Pick Color</button>
                <button id="modeErase" class="mode-btn w-1/3 py-2 px-4 rounded-md text-sm font-medium transition">Smart Erase</button>
                <button id="modeRestore" class="mode-btn w-1/3 py-2 px-4 rounded-md text-sm font-medium transition">Restore</button>
            </div>
            <!-- Color Picker -->
            <div id="color-picker-control" class="flex items-center justify-center space-x-4">
                 <div>
                    <label for="colorPicker" class="block mb-2 text-sm font-medium text-gray-300">Target Color</label>
                    <input id="colorPicker" type="color" value="#ffffff">
                </div>
            </div>
            <!-- Tolerance Controls -->
            <div id="tolerance-control" class="w-full px-4">
                 <label for="toleranceSlider" class="block mb-2 text-sm font-medium text-gray-300">Tolerance: <span id="toleranceValue" class="font-bold text-indigo-400">50</span></label>
                 <input id="toleranceSlider" type="range" min="0" max="255" value="50" class="w-full">
            </div>
             <!-- Brush Size Controls -->
            <div id="brush-control" class="hidden w-full px-4">
                <label for="brushSlider" class="block mb-2 text-sm font-medium text-gray-300">Brush Size: <span id="brushValue" class="font-bold text-indigo-400">50</span></label>
                <input id="brushSlider" type="range" min="1" max="200" value="50" class="w-full">
            </div>
        </div>

        <!-- Action Buttons -->
        <div id="action-buttons" class="hidden flex flex-wrap justify-center gap-4">
            <button id="undoBtn" class="action-btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 inline-flex items-center" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7.707 3.293a1 1 0 010 1.414L5.414 7H11a7 7 0 017 7v2a1 1 0 11-2 0v-2a5 5 0 00-5-5H5.414l2.293 2.293a1 1 0 11-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
            </button>
            <button id="redoBtn" class="action-btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 inline-flex items-center" disabled>
                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.293 3.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L14.586 9H9a5 5 0 00-5 5v2a1 1 0 11-2 0v-2a7 7 0 017-7h5.586l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
            </button>
            <button id="resetBtn" class="action-btn bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 inline-flex items-center">Reset</button>
            <button id="downloadBtn" class="action-btn bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 inline-flex items-center">Download</button>
        </div>
         <p id="message" class="text-gray-500 mt-4"></p>
    </div>

    <script>
        // DOM Elements
        const imageLoader = document.getElementById('imageLoader');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const imageCanvas = document.getElementById('imageCanvas');
        const drawCanvas = document.getElementById('drawCanvas');
        const ctx = imageCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        const actionButtons = document.getElementById('action-buttons');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const controlsContainer = document.getElementById('controls-container');
        const colorPickerControl = document.getElementById('color-picker-control');
        const toleranceControl = document.getElementById('tolerance-control');
        const brushControl = document.getElementById('brush-control');
        const toleranceSlider = document.getElementById('toleranceSlider');
        const toleranceValue = document.getElementById('toleranceValue');
        const brushSlider = document.getElementById('brushSlider');
        const brushValue = document.getElementById('brushValue');
        const colorPicker = document.getElementById('colorPicker');
        const message = document.getElementById('message');
        const modeColorBtn = document.getElementById('modeColor');
        const modeEraseBtn = document.getElementById('modeErase');
        const modeRestoreBtn = document.getElementById('modeRestore');

        // State variables
        let originalFileName = '';
        let trueOriginalImageData = null;
        let targetColor = { r: 255, g: 255, b: 255 };
        let eraseStartColor = { r: 0, g: 0, b: 0 };
        let currentMode = 'color';
        let isDrawing = false;
        let lastX, lastY; // For smooth brush strokes
        
        let history = [];
        let historyIndex = -1;

        // --- Event Listeners ---
        imageLoader.addEventListener('change', handleImageUpload);
        toleranceSlider.addEventListener('input', () => {
            toleranceValue.textContent = toleranceSlider.value;
            if (currentMode === 'color') processImageByColor();
        });
        colorPicker.addEventListener('input', () => {
            targetColor = hexToRgb(colorPicker.value);
            if (currentMode === 'color') processImageByColor();
        });
        brushSlider.addEventListener('input', () => brushValue.textContent = brushSlider.value);
        resetBtn.addEventListener('click', handleReset);
        downloadBtn.addEventListener('click', handleDownload);
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        modeColorBtn.addEventListener('click', () => setMode('color'));
        modeEraseBtn.addEventListener('click', () => setMode('erase'));
        modeRestoreBtn.addEventListener('click', () => setMode('restore'));

        imageCanvas.addEventListener('mousedown', handleMouseDown);
        imageCanvas.addEventListener('mousemove', handleMouseMove);
        imageCanvas.addEventListener('mouseup', handleMouseUp);
        imageCanvas.addEventListener('mouseleave', handleMouseUp);
        
        // --- History Management ---
        function saveState() {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            history.push(ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height));
            historyIndex++;
            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                ctx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                ctx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }
        
        function updateHistoryButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }
        
        function clearHistory() {
            history = [];
            historyIndex = -1;
        }

        // --- Mode Management ---
        function setMode(mode) {
            currentMode = mode;
            modeColorBtn.classList.toggle('active', mode === 'color');
            modeEraseBtn.classList.toggle('active', mode === 'erase');
            modeRestoreBtn.classList.toggle('active', mode === 'restore');
            
            colorPickerControl.classList.toggle('hidden', mode !== 'color');
            brushControl.classList.toggle('hidden', mode === 'color');
            toleranceControl.classList.toggle('hidden', mode === 'restore');

            imageCanvas.style.cursor = mode === 'color' ? 'crosshair' : 'cell';
        }

        // --- Color Utility Functions ---
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
        }

        // --- Main Handlers ---
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) { message.textContent = 'No file selected.'; return; }
            message.textContent = 'Processing image...';
            actionButtons.classList.add('hidden');
            controlsContainer.classList.add('hidden');
            canvasWrapper.classList.add('hidden'); // Hide wrapper initially
            originalFileName = file.name.split('.').slice(0, -1).join('.');
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    const containerWidth = canvasWrapper.parentElement.clientWidth;
                    const scale = Math.min(1, containerWidth / img.naturalWidth);
                    const displayWidth = img.naturalWidth * scale;
                    const displayHeight = img.naturalHeight * scale;

                    [imageCanvas, drawCanvas].forEach(c => { c.width = img.naturalWidth; c.height = img.naturalHeight; });
                    [imageCanvas, drawCanvas].forEach(c => { c.style.width = `${displayWidth}px`; c.style.height = `${displayHeight}px`; });
                    canvasWrapper.style.height = `${displayHeight}px`;

                    ctx.drawImage(img, 0, 0);
                    trueOriginalImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                    
                    clearHistory();
                    saveState();

                    canvasWrapper.classList.remove('hidden'); // Show wrapper now
                    controlsContainer.classList.remove('hidden');
                    actionButtons.classList.remove('hidden');
                    message.textContent = 'Upload complete. Choose a mode to start editing.';
                    setMode('color');
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(file);
        }

        function handleReset() {
             if (!trueOriginalImageData) return;
             ctx.putImageData(trueOriginalImageData, 0, 0);
             saveState();
             message.textContent = 'Image has been reset.';
        }

        // --- Mouse Drawing Handlers ---
        function getMousePos(e) {
            const rect = imageCanvas.getBoundingClientRect();
            const scaleX = imageCanvas.width / rect.width;
            const scaleY = imageCanvas.height / rect.height;
            return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
        }

        function handleMouseDown(e) {
            const pos = getMousePos(e);
            if (currentMode === 'color') {
                processImageByColor();
            } else if (currentMode === 'erase' || currentMode === 'restore') {
                isDrawing = true;
                [lastX, lastY] = [pos.x, pos.y]; // Set start point for line
                if (currentMode === 'erase') {
                    const pixel = ctx.getImageData(pos.x, pos.y, 1, 1).data;
                    eraseStartColor = { r: pixel[0], g: pixel[1], b: pixel[2] };
                }
                // Apply brush at the starting point for single clicks
                applyBrush(pos.x, pos.y);
            }
        }

        function handleMouseMove(e) {
            const pos = getMousePos(e);
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            if (currentMode === 'erase' || currentMode === 'restore') {
                const scale = imageCanvas.getBoundingClientRect().width / imageCanvas.width;
                drawCtx.beginPath();
                drawCtx.arc(pos.x, pos.y, brushSlider.value / 2, 0, 2 * Math.PI);
                drawCtx.strokeStyle = currentMode === 'restore' ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)';
                drawCtx.lineWidth = 1 / scale;
                drawCtx.stroke();
                if (isDrawing) {
                    // Draw a line of brush strokes from last point to current point
                    drawLine(lastX, lastY, pos.x, pos.y);
                    [lastX, lastY] = [pos.x, pos.y]; // Update last point
                }
            }
        }

        function handleMouseUp() {
            if (isDrawing) {
                isDrawing = false;
                saveState();
            }
        }
        
        // --- Image Processing ---
        
        /** Draws a continuous line of brush strokes between two points */
        function drawLine(x0, y0, x1, y1) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;

            while (true) {
                applyBrush(x0, y0);

                if ((x0 === x1) && (y0 === y1)) break;
                let e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }
        
        function applyBrush(cx, cy) {
            const radius = brushSlider.value / 2;
            const tolerance = parseInt(toleranceSlider.value, 10);
            
            const imageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
            const data = imageData.data;
            const originalData = trueOriginalImageData.data;
            const width = imageCanvas.width;

            const startX = Math.max(0, Math.floor(cx - radius));
            const endX = Math.min(width, Math.ceil(cx + radius));
            const startY = Math.max(0, Math.floor(cy - radius));
            const endY = Math.min(imageCanvas.height, Math.ceil(cy + radius));

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const distSq = Math.pow(x - cx, 2) + Math.pow(y - cy, 2);
                    if (distSq < Math.pow(radius, 2)) {
                        const index = (y * width + x) * 4;
                        if (currentMode === 'erase') {
                            const r = data[index], g = data[index + 1], b = data[index + 2];
                            const colorDist = Math.sqrt(Math.pow(r - eraseStartColor.r, 2) + Math.pow(g - eraseStartColor.g, 2) + Math.pow(b - eraseStartColor.b, 2));
                            if (colorDist < tolerance) data[index + 3] = 0;
                        } else { // Restore mode
                            data[index] = originalData[index];
                            data[index + 1] = originalData[index + 1];
                            data[index + 2] = originalData[index + 2];
                            data[index + 3] = originalData[index + 3];
                        }
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function processImageByColor() {
            if (!trueOriginalImageData) return;
            
            const currentImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
            const data = currentImageData.data;
            const tolerance = parseInt(toleranceSlider.value, 10);
            const { r: tr, g: tg, b: tb } = targetColor;
            toleranceValue.textContent = tolerance;
            
            const originalData = trueOriginalImageData.data;

            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    const r = originalData[i], g = originalData[i+1], b = originalData[i+2];
                    const distance = Math.sqrt(Math.pow(r - tr, 2) + Math.pow(g - tg, 2) + Math.pow(b - tb, 2));
                    if (distance < tolerance) data[i + 3] = 0;
                }
            }
            ctx.putImageData(currentImageData, 0, 0);
            saveState();
        }

        // --- Download ---
        function handleDownload() {
            const link = document.createElement('a');
            link.download = `${originalFileName}_transparent.png`;
            link.href = imageCanvas.toDataURL('image/png');
            link.click();
        }
    </script>
</body>
</html>
